<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>B·∫£ng ƒêi·ªÅu Khi·ªÉn Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    h1 {
      color: #333;
      margin-bottom: 30px;
      text-align: center;
    }

    .section {
      margin-bottom: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 10px;
    }

    .section h2 {
      color: #555;
      margin-bottom: 15px;
      font-size: 18px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      color: #666;
      font-weight: bold;
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .button-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 12px 20px;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover {
      background: #5568d3;
      transform: translateY(-2px);
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn-success:hover {
      background: #218838;
      transform: translateY(-2px);
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-danger:hover {
      background: #c82333;
      transform: translateY(-2px);
    }

    .btn-info {
      background: #17a2b8;
      color: white;
    }

    .btn-info:hover {
      background: #138496;
      transform: translateY(-2px);
    }

    .btn-warning {
      background: #ffc107;
      color: #333;
    }

    .btn-warning:hover {
      background: #e0a800;
      transform: translateY(-2px);
    }

    .status {
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      font-weight: bold;
    }

    .status.connected {
      background: #d4edda;
      color: #155724;
    }

    .status.disconnected {
      background: #f8d7da;
      color: #721c24;
    }

    .test-section {
      background: #fff3cd;
    }

    .auto-section {
      background: #e7f3ff;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .checkbox-group input[type="checkbox"] {
      width: auto;
    }

    .inline-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .player-list {
      max-height: 200px;
      overflow-y: auto;
      background: white;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
    }

    .player-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .player-item:last-child {
      border-bottom: none;
    }

    .player-avatar {
      width: 30px;
      height: 30px;
      border-radius: 50%;
    }

    .log-section {
      max-height: 150px;
      overflow-y: auto;
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
    }

    .log-item {
      padding: 3px 0;
      color: #666;
    }

    .log-item.success {
      color: #28a745;
    }

    .log-item.error {
      color: #dc3545;
    }

    /* Comment Item Styles */
    .comment-item {
      display: flex;
      gap: 10px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      transition: all 0.2s;
      position: relative;
    }

    .comment-item:hover {
      background: #e9ecef;
      border-color: #667eea;
      transform: translateX(2px);
    }

    .comment-item.pinned {
      background: #fff3cd;
      border-color: #ffc107;
    }

    .comment-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      flex-shrink: 0;
    }

    .comment-content {
      flex: 1;
      min-width: 0;
    }

    .comment-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .comment-author {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }

    .comment-time {
      font-size: 11px;
      color: #999;
    }

    .comment-text {
      color: #555;
      font-size: 13px;
      word-wrap: break-word;
      margin-bottom: 4px;
    }

    .comment-id {
      font-size: 10px;
      color: #aaa;
      font-family: monospace;
    }

    .pin-button {
      padding: 6px 12px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .pin-button:hover {
      background: #ffc107;
      border-color: #ffc107;
      transform: scale(1.1);
    }

    .pin-button.pinned {
      background: #ffc107;
      border-color: #ffc107;
    }

    /* Error/System comment styling for dashboard */
    .comment-item.error {
      background: linear-gradient(135deg, #ffe5e5 0%, #ffcccc 100%);
      border: 2px solid #dc3545;
      box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
      animation: errorPulse 2s ease-in-out infinite;
    }

    .comment-item.error .comment-author {
      color: #dc3545;
      font-weight: 700;
      font-size: 15px;
    }

    .comment-item.error .comment-text {
      color: #721c24;
      font-weight: 500;
      white-space: pre-line;
      font-size: 14px;
    }

    .comment-item.error::before {
      content: '‚ö†Ô∏è';
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 20px;
      animation: shake 0.5s ease-in-out infinite;
    }

    @keyframes errorPulse {

      0%,
      100% {
        box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
      }

      50% {
        box-shadow: 0 4px 25px rgba(220, 53, 69, 0.5);
      }
    }

    @keyframes shake {

      0%,
      100% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-2px);
      }

      75% {
        transform: translateX(2px);
      }
    }

    #commentListContainer::-webkit-scrollbar {
      width: 8px;
    }

    #commentListContainer::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }

    #commentListContainer::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 10px;
    }

    #commentListContainer::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Game State Visualization Styles */
    .game-state-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 280px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      border: 2px solid rgba(102, 126, 234, 0.2);
    }

    .game-state-panel h2 {
      font-size: 14px;
      margin-bottom: 12px;
      color: #333;
      text-align: center;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }

    .state-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: white;
      border-radius: 6px;
      margin-bottom: 6px;
      border-left: 4px solid #ccc;
      transition: all 0.3s;
      opacity: 0.5;
    }

    .state-indicator.active {
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
      transform: scale(1.05);
      opacity: 1;
      font-weight: 600;
    }

    .state-indicator.pending {
      border-left-color: #6c757d;
    }

    .state-indicator.pending.active {
      background: #f8f9fa;
    }

    .state-indicator.savedSettings {
      border-left-color: #17a2b8;
    }

    .state-indicator.savedSettings.active {
      background: #d1ecf1;
    }

    .state-indicator.init {
      border-left-color: #ffc107;
    }

    .state-indicator.init.active {
      background: #fff3cd;
    }

    .state-indicator.prepare {
      border-left-color: #fd7e14;
    }

    .state-indicator.prepare.active {
      background: #ffe5d0;
    }

    .state-indicator.playing {
      border-left-color: #28a745;
    }

    .state-indicator.playing.active {
      background: #d4edda;
    }

    .state-indicator.completing {
      border-left-color: #007bff;
    }

    .state-indicator.completing.active {
      background: #cce5ff;
    }

    .state-indicator.completed {
      border-left-color: #6f42c1;
    }

    .state-indicator.completed.active {
      background: #e2d9f3;
    }

    .state-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ccc;
      transition: all 0.3s;
      flex-shrink: 0;
    }

    .state-indicator.active .state-dot {
      background: currentColor;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.6;
        transform: scale(1.2);
      }
    }

    .state-label {
      flex: 1;
      font-size: 12px;
      color: #333;
    }

    .state-description {
      font-size: 10px;
      color: #666;
      font-weight: normal;
      margin-top: 2px;
    }

    .players-added-section {
      background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
      padding: 10px;
      border-radius: 6px;
      margin-top: 10px;
      border: 1px solid #4caf50;
    }

    .players-added-section h4 {
      margin: 0 0 6px 0;
      color: #2e7d32;
      font-size: 13px;
    }

    .players-added-section div {
      font-size: 10px;
    }

    .player-list-container {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 8px;
      background: white;
      border-radius: 4px;
      padding: 8px;
    }

    .player-list-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      border-bottom: 1px solid #e0e0e0;
      font-size: 11px;
    }

    .player-list-item:last-child {
      border-bottom: none;
    }

    .player-list-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .player-list-name {
      flex: 1;
      color: #333;
      font-weight: 500;
    }

    .player-list-empty {
      text-align: center;
      color: #999;
      padding: 12px;
      font-size: 11px;
    }

    .player-list-container::-webkit-scrollbar {
      width: 4px;
    }

    .player-list-container::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .player-list-container::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 2px;
    }
  </style>
</head>

<body>
  <!-- Floating Game State Panel -->
  <div class="game-state-panel">
    <h2>üéÆ Tr·∫°ng Th√°i</h2>

    <div class="state-indicator pending" data-state="pending">
      <div class="state-dot" style="color: #6c757d;"></div>
      <div class="state-label">
        PENDING
        <div class="state-description">Ch·ªù c·∫•u h√¨nh</div>
      </div>
    </div>

    <div class="state-indicator savedSettings" data-state="savedSettings">
      <div class="state-dot" style="color: #17a2b8;"></div>
      <div class="state-label">
        SAVED
        <div class="state-description">ƒê√£ l∆∞u</div>
      </div>
    </div>

    <div class="state-indicator init" data-state="init">
      <div class="state-dot" style="color: #ffc107;"></div>
      <div class="state-label">
        INIT
        <div class="state-description">Nh·∫≠n comment</div>
      </div>
    </div>

    <div class="state-indicator prepare" data-state="prepare">
      <div class="state-dot" style="color: #fd7e14;"></div>
      <div class="state-label">
        PREPARE
        <div class="state-description">Chu·∫©n b·ªã</div>
      </div>
    </div>

    <div class="state-indicator playing" data-state="playing">
      <div class="state-dot" style="color: #28a745;"></div>
      <div class="state-label">
        PLAYING
        <div class="state-description">ƒêang ch∆°i</div>
      </div>
    </div>

    <div class="state-indicator completing" data-state="completing">
      <div class="state-dot" style="color: #007bff;"></div>
      <div class="state-label">
        COMPLETING
        <div class="state-description">Ho√†n th√†nh</div>
      </div>
    </div>

    <div class="state-indicator completed" data-state="completed">
      <div class="state-dot" style="color: #6f42c1;"></div>
      <div class="state-label">
        COMPLETED
        <div class="state-description">K·∫øt th√∫c</div>
      </div>
    </div>

    <div class="players-added-section">
      <h4>üë• Ng∆∞·ªùi ch∆°i: <span id="playersAddedCount">0</span></h4>
      <div style="font-size: 10px; color: #666;">
        <strong>Ph√≤ng:</strong> <span id="roomIdDisplay">-</span><br>
        <strong>T·ª´ kh√≥a:</strong> <span id="keywordDisplay">-</span>
      </div>
      <div class="player-list-container" id="addedPlayersList">
        <div class="player-list-empty">Ch∆∞a c√≥ ng∆∞·ªùi ch∆°i</div>
      </div>
    </div>
  </div>

  <div class="container">
    <h1>üéÆ B·∫£ng ƒêi·ªÅu Khi·ªÉn Game</h1>



    <div class="section">
      <h2>üì° K·∫øt N·ªëi</h2>
      <div id="status" class="status disconnected">Ch∆∞a k·∫øt n·ªëi</div>
    </div>

    <div class="section">
      <h2>‚öôÔ∏è C·∫•u H√¨nh Game</h2>

      <div class="form-group">
        <label>ID Ph√≤ng:</label>
        <input type="text" id="inputRoomId" value="test-room-123" />
      </div>

      <div class="form-group">
        <label>Ch·ªß ƒë·ªÅ:</label>
        <select id="theme">

          <!-- <option value="duck">V·ªãt ü¶Ü</option>

          <option value="cow">B√≤ üêÑ</option> -->
          <option value="unicorn">Tu·∫ßn l·ªôc ü¶Ñ</option>
          <option value="horse">Ng·ª±a üê¥</option>
          <!-- <option value="car">Xe H∆°i üöó</option>
          <option value="bear">G·∫•u üêª</option> -->
        </select>
      </div>

      <div class="form-group">
        <label>T·ª´ kh√≥a:</label>
        <input type="text" id="keyword" value="hanagold" />
      </div>

      <div class="form-group">
        <label>Ch·∫ø ƒë·ªô ch∆°i:</label>
        <select id="mode">
          <option value="random">Ng·∫´u nhi√™n</option>
          <option value="score">Hybrid (K·∫øt h·ª£p)</option>
        </select>
      </div>

      <div class="inline-group">
        <div class="form-group">
          <label>Th·ªùi gian (GG:PP:SS):</label>
          <input type="text" id="timer" value="00:00:30" />
        </div>

        <div class="form-group">
          <label>S·ªë ng∆∞·ªùi th·∫Øng:</label>
          <input type="number" id="winnersCount" value="3" min="1" max="10" />
        </div>
      </div>

      <div class="inline-group">
        <div class="form-group">
          <label>S·ªë ng∆∞·ªùi t·ªëi ƒëa:</label>
          <input type="number" id="maxCharacters" value="50" min="1" max="1000" />
        </div>

        <div class="form-group">
          <label>√Çm l∆∞·ª£ng (0-100):</label>
          <input type="number" id="volume" value="50" min="0" max="100" />
        </div>
      </div>

      <div class="form-group checkbox-group">
        <input type="checkbox" id="enableSound" checked />
        <label for="enableSound" style="margin-bottom: 0;">B·∫≠t √¢m thanh</label>
      </div>

      <button class="btn-primary" onclick="saveConfig()">üíæ L∆∞u C·∫•u H√¨nh</button>
    </div>

    <div class="section">
      <h2>üéØ ƒêi·ªÅu Khi·ªÉn Game</h2>
      <div class="button-group">
        <button class="btn-success" onclick="initGame()">üé¨ Kh·ªüi T·∫°o</button>
        <button class="btn-success" onclick="runGame()">‚ñ∂Ô∏è B·∫Øt ƒê·∫ßu</button>
        <button class="btn-danger" onclick="resetGame()">üîÑ L√†m M·ªõi</button>
        <button class="btn-info" onclick="showTopWinners()">üèÜ Top Th·∫Øng</button>
        <button class="btn-info" onclick="showResultList()">üìã K·∫øt Qu·∫£</button>
      </div>
    </div>

    <div class="section" style="background: #e8f5e9;">
      <h2>üí¨ C·∫•u H√¨nh Facebook Comments</h2>

      <div class="form-group">
        <label>Video ID:</label>
        <input type="text" id="commentVideoId" placeholder="Nh·∫≠p Facebook Live Video ID" />
        <small style="color: #666; display: block; margin-top: 5px;">
          V√≠ d·ª•: 1160226539653463
        </small>
      </div>

      <div class="form-group">
        <label>Access Token:</label>
        <input type="text" id="commentAccessToken" placeholder="Nh·∫≠p Facebook Access Token" />
        <small style="color: #666; display: block; margin-top: 5px;">
          Token c·∫ßn quy·ªÅn truy c·∫≠p comments c·ªßa video
        </small>
      </div>

      <div class="form-group">
        <label>Cookie:</label>
        <textarea id="commentCookie" placeholder="Nh·∫≠p Facebook Cookie" rows="3" style="resize: vertical;"></textarea>
        <small style="color: #666; display: block; margin-top: 5px;">
          Cookie t·ª´ tr√¨nh duy·ªát khi ƒë√£ ƒëƒÉng nh·∫≠p Facebook
        </small>
      </div>

      <div class="inline-group">
        <div class="form-group">
          <label>Polling Interval (ms):</label>
          <input type="number" id="commentPollingInterval" value="1000" min="500" max="10000" step="100" />
        </div>

        <div class="form-group checkbox-group" style="align-items: flex-end;">
          <input type="checkbox" id="commentEnabled" />
          <label for="commentEnabled" style="margin-bottom: 0;">B·∫≠t thu th·∫≠p comments</label>
        </div>
      </div>

      <div class="button-group">
        <button class="btn-success" onclick="saveCommentConfig()">üíæ L∆∞u C·∫•u H√¨nh</button>
        <button class="btn-info" onclick="testCommentConnection()">üîç Test K·∫øt N·ªëi</button>
        <button class="btn-primary" onclick="openShowCmt()">üì∫ M·ªü /showcmt</button>
      </div>

      <div class="button-group" style="margin-top: 10px;">
        <button class="btn-success" onclick="startCommentPolling()">‚ñ∂Ô∏è B·∫Øt ƒê·∫ßu Polling</button>
        <button class="btn-danger" onclick="stopCommentPolling()">‚èπÔ∏è D·ª´ng Polling</button>
      </div>

      <div id="commentStatus" style="margin-top: 10px; padding: 10px; border-radius: 5px; display: none;"></div>

      <!-- Comment List Section -->
      <div style="margin-top: 20px;">
        <h3 style="margin-bottom: 10px;">üìù Danh S√°ch Comments</h3>

        <div class="form-group">
          <input type="text" id="commentSearch" placeholder="üîç T√¨m ki·∫øm comments..." oninput="filterComments()"
            style="margin-bottom: 10px;" />
        </div>

        <div id="commentListContainer"
          style="max-height: 400px; overflow-y: auto; background: white; border-radius: 5px; padding: 10px;">
          <div id="commentList" style="display: flex; flex-direction: column; gap: 10px;">
            <div style="text-align: center; color: #999; padding: 20px;">
              Ch∆∞a c√≥ comments. B·∫≠t thu th·∫≠p ƒë·ªÉ xem comments.
            </div>
          </div>
        </div>

        <div style="margin-top: 10px; font-size: 12px; color: #666;">
          T·ªïng: <span id="totalComments">0</span> comments |
          Hi·ªÉn th·ªã: <span id="displayedComments">0</span> comments
        </div>
      </div>
    </div>



    <div class="section">
      <h2>üìä Nh·∫≠t K√Ω Ho·∫°t ƒê·ªông</h2>
      <div id="logSection" class="log-section">
        <div class="log-item">S·∫µn s√†ng...</div>
      </div>
      <button class="btn-info" onclick="clearLogs()" style="margin-top: 10px;">üóëÔ∏è X√≥a Nh·∫≠t K√Ω</button>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const base = `http://localhost:8182`
    const base2 = `https://server-game-zk1e.onrender.com`
    const API_BASE_URL = base2;
    const socket = io(API_BASE_URL);
    let currentRoomId = document.getElementById('inputRoomId').value;
    let gameState = {
      state: 'pending',
      count: 0
    };
    let playersAddedCount = 0;
    let addedPlayersList = [];
    // Socket connection
    socket.on('connect', () => {
      updateStatus(true);
      addLog('ƒê√£ k·∫øt n·ªëi ƒë·∫øn server', 'success');
      subscribeToRoom();
      // Initialize with PENDING state
      updateGameStateVisualization('pending');
    });

    socket.on('disconnect', () => {
      updateStatus(false);
      addLog('M·∫•t k·∫øt n·ªëi v·ªõi server', 'error');
    });

    // L·∫Øng nghe tr·∫°ng th√°i game t·ª´ Game View
    socket.on('onDucky', (data) => {
      console.log('Received action from Game View/Server:', data);

      if (data.action === 'pingController') {
        gameState = data.data;
        updateGameInfo();
        updateGameStateVisualization(gameState.state);
      }

      if (data.action === 'changeGameStage') {
        gameState.state = data.data;
        updateGameInfo();
        updateGameStateVisualization(data.data);
      }

      if (data.action === 'addedCharacter') {
        gameState.count = data.data;
        playersAddedCount = data.data;
        updateGameInfo();
      }

      // Hi·ªÉn th·ªã log cho c√°c l·ªánh ƒëi·ªÅu khi·ªÉn ƒë∆∞·ª£c g·ª≠i ƒëi
      if (['initGame', 'runGame', 'resetGame', 'showTopWinners', 'showResultList'].includes(data.action)) {
        addLog(`Server ƒë√£ ph·∫£n h·ªìi l·ªánh ƒëi·ªÅu khi·ªÉn: ${data.action}`, 'success');
      }

    });

    // Listen for game state changes from server
    socket.on('game_state_changed', (data) => {
      console.log('Game state changed:', data);
      if (data.state) {
        gameState.state = data.state;
        updateGameStateVisualization(data.state);
        addLog(`Tr·∫°ng th√°i game: ${data.state}`, 'info');
      }
    });

    // Listen for Facebook comments
    let allComments = [];
    let pinnedComments = new Set();

    socket.on('facebook_comment', (comments) => {
      console.log('üì• Received Facebook comments:', comments);
      console.log('üéÆ Current game state:', gameState.state);

      // Add new comments to the list
      comments.forEach(comment => {
        // Check if comment already exists
        const exists = allComments.some(c => c.id === comment.id);
        if (!exists) {
          allComments.unshift(comment); // Add to beginning

          console.log('üí¨ Processing comment:', {
            name: comment.author.name,
            text: comment.text,
            isError: comment.metadata?.isError,
            gameState: gameState.state
          });

          // If server marked this as a player comment (passed keyword filter in INIT state)
          if (comment.metadata?.isPlayerComment && !comment.metadata?.isError) {
            // Check if player already exists by author.id (safety check)
            const playerExists = addedPlayersList.some(p => p.id === comment.author.id);

            if (!playerExists) {
              playersAddedCount++;
              // Add to player list
              addedPlayersList.push({
                id: comment.author.id,
                name: comment.author.name,
                avatar: comment.author.avatar
              });
              console.log('‚úÖ Added to player list:', comment.author.name);
              console.log('üìä Total players:', playersAddedCount);
              console.log('üìã Player list:', addedPlayersList);
              updateGameInfo();
              updatePlayerListDisplay();
              addLog(`‚úÖ ƒê√£ th√™m ng∆∞·ªùi ch∆°i: ${comment.author.name}`, 'success');
            } else {
              console.log('‚ö†Ô∏è Player already exists, skipping:', comment.author.name, comment.author.id);
              addLog(`‚ö†Ô∏è Ng∆∞·ªùi ch∆°i ƒë√£ t·ªìn t·∫°i: ${comment.author.name}`, 'warning');
            }
          } else {
            console.log('‚ÑπÔ∏è Not a player comment - isPlayerComment:', comment.metadata?.isPlayerComment, 'isError:', comment.metadata?.isError);
            addLog(`üí¨ Comment m·ªõi t·ª´ ${comment.author.name}`, 'success');
          }
        } else {
          console.log('‚ö†Ô∏è Duplicate comment, skipping:', comment.id);
        }
      });

      // Limit to 250 comments (including errors)
      if (allComments.length > 250) {
        allComments = allComments.slice(0, 250);
      }

      // Update display
      displayComments();
    });

    function displayComments() {
      const commentList = document.getElementById('commentList');
      const searchTerm = document.getElementById('commentSearch').value.toLowerCase();

      // Filter comments based on search
      let filteredComments = allComments;
      if (searchTerm) {
        filteredComments = allComments.filter(comment =>
          comment.author.name.toLowerCase().includes(searchTerm) ||
          comment.text.toLowerCase().includes(searchTerm) ||
          comment.id.toLowerCase().includes(searchTerm)
        );
      }

      // Sort: pinned first, then by timestamp (errors flow normally)
      filteredComments.sort((a, b) => {
        const aPinned = pinnedComments.has(a.id);
        const bPinned = pinnedComments.has(b.id);

        // Pinned first
        if (aPinned && !bPinned) return -1;
        if (!aPinned && bPinned) return 1;

        // Then by timestamp (newest first)
        return b.timestamp - a.timestamp;
      });

      // Update counts
      document.getElementById('totalComments').textContent = allComments.length;
      document.getElementById('displayedComments').textContent = filteredComments.length;

      // Render comments
      if (filteredComments.length === 0) {
        commentList.innerHTML = `
          <div style="text-align: center; color: #999; padding: 20px;">
            ${searchTerm ? 'Kh√¥ng t√¨m th·∫•y comments ph√π h·ª£p' : 'Ch∆∞a c√≥ comments. B·∫≠t thu th·∫≠p ƒë·ªÉ xem comments.'}
          </div>
        `;
        return;
      }

      commentList.innerHTML = filteredComments.map(comment => {
        const isError = comment.metadata?.isError || comment.platform?.name === 'system';
        const isPinned = pinnedComments.has(comment.id);
        const timeAgo = formatTimeAgo(comment.timestamp);

        return `
          <div class="comment-item ${isError ? 'error' : ''} ${isPinned ? 'pinned' : ''}" data-comment-id="${comment.id}">
            <img src="${comment.author.avatar || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(comment.author.name)}" 
                 class="comment-avatar" 
                 alt="${escapeHtml(comment.author.name)}"
                 onerror="this.src='https://ui-avatars.com/api/?name=${encodeURIComponent(comment.author.name)}'">
            <div class="comment-content">
              <div class="comment-header">
                <span class="comment-author">${escapeHtml(comment.author.name)}</span>
                <span class="comment-time">${timeAgo}</span>
              </div>
              <div class="comment-text">${escapeHtml(comment.text)}</div>
              <div class="comment-id">ID: ${comment.id}</div>
            </div>
            ${!isError ? `
            <button class="pin-button ${isPinned ? 'pinned' : ''}" 
                    onclick="togglePin('${comment.id}')" 
                    title="${isPinned ? 'B·ªè ghim' : 'Ghim comment'}">
              ${isPinned ? 'üìå' : 'üìç'}
            </button>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    function filterComments() {
      displayComments();
    }

    function togglePin(commentId) {
      const isPinned = pinnedComments.has(commentId);

      if (isPinned) {
        pinnedComments.delete(commentId);
        addLog(`ƒê√£ b·ªè ghim comment ${commentId}`, 'info');
      } else {
        pinnedComments.add(commentId);
        addLog(`ƒê√£ ghim comment ${commentId}`, 'info');
      }

      // Broadcast pin event to all clients (including showcmt)
      socket.emit('call', 'pin.comment', {
        room: currentRoomId,
        commentId: commentId,
        pinned: !isPinned
      }, (error) => {
        if (error) {
          console.error('Error broadcasting pin event:', error);
        } else {
          console.log('Pin event broadcasted:', commentId, !isPinned);
        }
      });

      displayComments();
    }

    function formatTimeAgo(timestamp) {
      const now = Date.now();
      const diff = Math.floor((now - timestamp) / 1000); // seconds

      if (diff < 60) return 'V·ª´a xong';
      if (diff < 3600) return `${Math.floor(diff / 60)} ph√∫t tr∆∞·ªõc`;
      if (diff < 86400) return `${Math.floor(diff / 3600)} gi·ªù tr∆∞·ªõc`;
      return new Date(timestamp).toLocaleDateString('vi-VN');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }


    function updateStatus(connected) {
      const statusEl = document.getElementById('status');
      if (connected) {
        statusEl.textContent = 'ƒê√£ k·∫øt n·ªëi';
        statusEl.className = 'status connected';
      } else {
        statusEl.textContent = 'Ch∆∞a k·∫øt n·ªëi';
        statusEl.className = 'status disconnected';
      }
    }

    function updateGameInfo() {
      document.getElementById('playersAddedCount').textContent = playersAddedCount;
      document.getElementById('roomIdDisplay').textContent = currentRoomId;
      document.getElementById('keywordDisplay').textContent = document.getElementById('keyword').value || '-';
    }

    function updatePlayerListDisplay() {
      const container = document.getElementById('addedPlayersList');

      if (addedPlayersList.length === 0) {
        container.innerHTML = '<div class="player-list-empty">Ch∆∞a c√≥ ng∆∞·ªùi ch∆°i</div>';
        return;
      }

      container.innerHTML = addedPlayersList.map(player => `
        <div class="player-list-item">
          <img src="${player.avatar || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(player.name)}" 
               class="player-list-avatar" 
               alt="${player.name}"
               onerror="this.src='https://ui-avatars.com/api/?name=${encodeURIComponent(player.name)}'">
          <span class="player-list-name">${player.name}</span>
        </div>
      `).join('');
    }

    function updateGameStateVisualization(state) {
      // Remove active class from all indicators
      document.querySelectorAll('.state-indicator').forEach(indicator => {
        indicator.classList.remove('active');
      });

      // Add active class to current state
      const currentIndicator = document.querySelector(`.state-indicator[data-state="${state}"]`);
      if (currentIndicator) {
        currentIndicator.classList.add('active');
      }

      addLog(`üéÆ Tr·∫°ng th√°i: ${state.toUpperCase()}`, 'info');
    }

    function addLog(message, type = '') {
      const logSection = document.getElementById('logSection');
      const logItem = document.createElement('div');
      logItem.className = `log-item ${type}`;
      const time = new Date().toLocaleTimeString('vi-VN');
      logItem.textContent = `[${time}] ${message}`;
      logSection.appendChild(logItem);
      logSection.scrollTop = logSection.scrollHeight;
    }

    function clearLogs() {
      document.getElementById('logSection').innerHTML = '<div class="log-item">S·∫µn s√†ng...</div>';
    }

    function subscribeToRoom() {
      currentRoomId = document.getElementById('inputRoomId').value;

      // Control Panel Subscribe ƒë·ªÉ nh·∫≠n c√°c th√¥ng b√°o chung c·ªßa ph√≤ng (room.config)
      socket.emit('call', 'live.subscribe', { id: currentRoomId }, (error) => {
        if (error) {
          console.error('Subscribe error:', error);
          addLog('L·ªói khi subscribe ph√≤ng', 'error');
        } else {
          console.log('Subscribed to room:', currentRoomId);
          updateGameInfo();
          addLog(`ƒê√£ subscribe v√†o ph√≤ng: ${currentRoomId}`, 'success');
          // Sau khi subscribe, g·ª≠i ping ƒë·ªÉ Game View g·ª≠i tr·∫°ng th√°i ng∆∞·ª£c l·∫°i
          sendAction('pingGameView');
        }
      });
    }

    async function saveConfig() {
      const config = {
        theme: document.getElementById('theme').value,
        keyword: document.getElementById('keyword').value,
        mode: document.getElementById('mode').value,
        timer: document.getElementById('timer').value,
        winnersCount: parseInt(document.getElementById('winnersCount').value),
        maxCharacters: parseInt(document.getElementById('maxCharacters').value),
        volume: parseInt(document.getElementById('volume').value),
        enableSound: document.getElementById('enableSound').checked,
        scoresForLike: 1,
        scoresForComment: 60,
        scoresForCent: 20
      };

      try {
        const response = await fetch(`${API_BASE_URL}/api/room/update-config`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            room: currentRoomId,
            config: config
          })
        });

        const result = await response.json();
        console.log('Config saved:', result);
        addLog('ƒê√£ l∆∞u c·∫•u h√¨nh th√†nh c√¥ng', 'success');
        alert('ƒê√£ l∆∞u c·∫•u h√¨nh th√†nh c√¥ng!');
      } catch (error) {
        console.error('Error saving config:', error);
        addLog('L·ªói khi l∆∞u c·∫•u h√¨nh', 'error');
        alert('L·ªói khi l∆∞u c·∫•u h√¨nh');
      }
    }

    // H√†m g·ª≠i l·ªánh ƒëi·ªÅu khi·ªÉn ƒë·∫øn server (Server s·∫Ω ph√°t l·∫°i ƒë·∫øn Game View)
    function sendAction(action, data = null) {
      socket.emit('call', 'load-comment.ducky', {
        room: currentRoomId,
        config: { action, data }
      }, (error) => {
        if (error) {
          console.error('Action error:', error);
          addLog(`L·ªói khi g·ª≠i action: ${action}`, 'error');
        } else {
          console.log('Action sent:', action);
          addLog(`ƒê√£ g·ª≠i action: ${action}`, 'info');
        }
      });
    }

    function initGame() {
      sendAction('initGame');
    }

    function runGame() {
      sendAction('runGame');
    }

    function resetGame() {
      if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën l√†m m·ªõi game kh√¥ng?')) {
        sendAction('resetGame');
        addLog('G·ª≠i l·ªánh reset game', 'info');
        playersAddedCount = 0;
        addedPlayersList = []; // Clear player list
        updateGameInfo();
        updatePlayerListDisplay();

        // G·ªçi API ƒë·ªÉ x√≥a d·ªØ li·ªáu tr√™n Server (t√πy ch·ªçn)
        fetch(`${API_BASE_URL}/api/room/${currentRoomId}/reset`, { method: 'POST' });
      }
    }

    function showTopWinners() {
      sendAction('showTopWinners', true);
    }

    function showResultList() {
      sendAction('showResultList', true);
    }


    // Initialize
    document.getElementById('inputRoomId').addEventListener('change', subscribeToRoom);

    // ============== COMMENT CONFIG FUNCTIONS ==============

    async function saveCommentConfig() {
      const config = {
        enabled: false, // Don't auto-start, user will click "B·∫Øt ƒê·∫ßu" button
        liveVideoId: document.getElementById('commentVideoId').value.trim(),
        accessToken: document.getElementById('commentAccessToken').value.trim(),
        cookie: document.getElementById('commentCookie').value.trim(),
        pollingInterval: parseInt(document.getElementById('commentPollingInterval').value),
      };

      if (!config.liveVideoId || !config.accessToken) {
        alert('Vui l√≤ng nh·∫≠p Video ID v√† Access Token!');
        return;
      }

      // Save to localStorage
      try {
        localStorage.setItem('fb_comment_config', JSON.stringify(config));
        addLog('ƒê√£ l∆∞u c·∫•u h√¨nh v√†o localStorage', 'success');
      } catch (e) {
        console.error('Error saving to localStorage:', e);
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/room/update-comment-config`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            room: currentRoomId,
            config: config
          })
        });

        const result = await response.json();
        console.log('Comment config saved:', result);

        if (result.status === 'SUCCESS') {
          showCommentStatus('ƒê√£ l∆∞u c·∫•u h√¨nh comments th√†nh c√¥ng! B·∫•m "B·∫Øt ƒê·∫ßu Polling" ƒë·ªÉ b·∫Øt ƒë·∫ßu.', 'success');
          addLog('ƒê√£ l∆∞u c·∫•u h√¨nh comments l√™n server', 'success');
        } else {
          showCommentStatus('L·ªói khi l∆∞u c·∫•u h√¨nh: ' + (result.message || 'Unknown error'), 'error');
          addLog('L·ªói khi l∆∞u c·∫•u h√¨nh comments', 'error');
        }
      } catch (error) {
        console.error('Error saving comment config:', error);
        showCommentStatus('L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
        addLog('L·ªói khi l∆∞u c·∫•u h√¨nh comments', 'error');
      }
    }

    async function startCommentPolling() {
      const videoId = document.getElementById('commentVideoId').value.trim();
      const accessToken = document.getElementById('commentAccessToken').value.trim();

      if (!videoId || !accessToken) {
        alert('Vui l√≤ng l∆∞u c·∫•u h√¨nh tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu polling!');
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/room/start-comment-polling`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            room: currentRoomId
          })
        });

        const result = await response.json();

        if (result.status === 'SUCCESS') {
          showCommentStatus('ƒê√£ b·∫Øt ƒë·∫ßu polling comments!', 'success');
          addLog('‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu polling comments t·ª´ Facebook', 'success');
        } else {
          showCommentStatus('L·ªói: ' + (result.message || 'Unknown error'), 'error');
          addLog('‚ùå L·ªói khi b·∫Øt ƒë·∫ßu polling', 'error');
        }
      } catch (error) {
        console.error('Error starting polling:', error);
        showCommentStatus('L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
        addLog('‚ùå L·ªói khi b·∫Øt ƒë·∫ßu polling', 'error');
      }
    }

    async function stopCommentPolling() {
      try {
        const response = await fetch(`${API_BASE_URL}/api/room/stop-comment-polling`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            room: currentRoomId
          })
        });

        const result = await response.json();

        if (result.status === 'SUCCESS') {
          showCommentStatus('ƒê√£ d·ª´ng polling comments!', 'success');
          addLog('‚èπÔ∏è ƒê√£ d·ª´ng polling comments', 'success');
        } else {
          showCommentStatus('L·ªói: ' + (result.message || 'Unknown error'), 'error');
          addLog('‚ùå L·ªói khi d·ª´ng polling', 'error');
        }
      } catch (error) {
        console.error('Error stopping polling:', error);
        showCommentStatus('L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
        addLog('‚ùå L·ªói khi d·ª´ng polling', 'error');
      }
    }

    async function testCommentConnection() {
      const videoId = document.getElementById('commentVideoId').value.trim();
      const accessToken = document.getElementById('commentAccessToken').value.trim();

      if (!videoId || !accessToken) {
        alert('Vui l√≤ng nh·∫≠p Video ID v√† Access Token!');
        return;
      }

      showCommentStatus('ƒêang ki·ªÉm tra k·∫øt n·ªëi...', 'info');
      addLog('ƒêang test k·∫øt n·ªëi Facebook API...', 'info');

      try {
        // Test by making a direct API call
        const testUrl = `https://graph.facebook.com/v19.0/${videoId}/comments?access_token=${accessToken}&limit=1`;
        const response = await fetch(testUrl);
        const data = await response.json();

        if (data.error) {
          showCommentStatus('L·ªói: ' + data.error.message, 'error');
          addLog('Test th·∫•t b·∫°i: ' + data.error.message, 'error');
        } else {
          showCommentStatus('K·∫øt n·ªëi th√†nh c√¥ng! T√¨m th·∫•y ' + (data.data?.length || 0) + ' comments.', 'success');
          addLog('Test th√†nh c√¥ng! API ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng.', 'success');
        }
      } catch (error) {
        console.error('Test error:', error);
        showCommentStatus('L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
        addLog('Test th·∫•t b·∫°i: ' + error.message, 'error');
      }
    }

    function showCommentStatus(message, type) {
      const statusEl = document.getElementById('commentStatus');
      statusEl.style.display = 'block';
      statusEl.textContent = message;

      // Set colors based on type
      if (type === 'success') {
        statusEl.style.background = '#d4edda';
        statusEl.style.color = '#155724';
      } else if (type === 'error') {
        statusEl.style.background = '#f8d7da';
        statusEl.style.color = '#721c24';
      } else if (type === 'info') {
        statusEl.style.background = '#d1ecf1';
        statusEl.style.color = '#0c5460';
      }

      // Auto hide after 5 seconds
      setTimeout(() => {
        statusEl.style.display = 'none';
      }, 5000);
    }

    function openShowCmt() {
      const url = `${API_BASE_URL}/showcmt?room=${currentRoomId}`;
      window.open(url, '_blank', 'width=800,height=600');
      addLog('ƒê√£ m·ªü trang hi·ªÉn th·ªã comments', 'info');
    }

    // Load comment config on page load
    async function loadCommentConfig() {
      // First, try to load from localStorage
      try {
        const savedConfig = localStorage.getItem('fb_comment_config');
        if (savedConfig) {
          const config = JSON.parse(savedConfig);
          document.getElementById('commentVideoId').value = config.liveVideoId || '';
          document.getElementById('commentAccessToken').value = config.accessToken || '';
          document.getElementById('commentCookie').value = config.cookie || '';
          document.getElementById('commentPollingInterval').value = config.pollingInterval || 1000;
          document.getElementById('commentEnabled').checked = config.enabled || false;
          addLog('ƒê√£ t·∫£i c·∫•u h√¨nh t·ª´ localStorage', 'success');
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
      }

      // Then, try to load from server (will override localStorage if exists)
      try {
        const response = await fetch(`${API_BASE_URL}/api/room/${currentRoomId}/comment-config`);
        const result = await response.json();

        if (result.status === 'SUCCESS' && result.config) {
          document.getElementById('commentVideoId').value = result.config.liveVideoId || '';
          document.getElementById('commentAccessToken').value = result.config.accessToken || '';
          document.getElementById('commentCookie').value = result.config.cookie || '';
          document.getElementById('commentPollingInterval').value = result.config.pollingInterval || 1000;
          document.getElementById('commentEnabled').checked = result.config.enabled || false;

          addLog('ƒê√£ t·∫£i c·∫•u h√¨nh t·ª´ server', 'success');
        }
      } catch (error) {
        console.error('Error loading comment config from server:', error);
      }
    }

    // Load config after subscribing to room
    setTimeout(loadCommentConfig, 1000);
  </script>
</body>

</html>